\\pairs of elements in an array whose sum equal to a number
a=[3,5,2,6,8,5,4,1]
k=7
for i in range(len(a)-1):
    for j in range(i+1,len(a)):
        if(a[i]+a[j]==k):
            print(a[i],a[j])

\\maximum 
a=[5,2,3,8,4,1,2]
maxi=a[0]
for i in range(1,len(a)):
    if(maxi>a[i]):
        maxi=a[i]
print("Maximum element in an array is",maxi)

\\Number of even and odd numbers in an array
a=[2,5,6,8,7,8,1,4]
even_count=0
odd_count=0
for n in a:
    if(n%2==0):
        even_count+=1
    else:
        odd_count+=1
print(even_count)
print(odd_count)

\\Reverse elements in an array
a=[2,5,6,9,3,4,5,7]
i,j=0,len(a)-1
while i<j:
    a[i],a[j]=a[j],a[i]
    i+=1
    j-=1
print(a)

\\Check Whether an array is Plaindrome or not same code as like Reverse an element
a=["c","b","a","c"]
i,j=0,len(a)-1
flag=True
while i<j:
    if(a[i]==a[j]):
        i+=1
        j-=1
    else:
        flag=False
        break
if flag:
    print(a,"It is an palindrome")
else:
    print("Not a palindrome")
\\Remove Duplicates from an array
a=[2,5,6,8,9,4,5,3,1,2]
seen=set()
new_a=[]
for num in a:
    if num not in seen:
        seen.add(num)
        new_a.append(num)
print(new_a)

\\Frequency of each element
a=[2,3,5,2,1,4,3,5]
visited=[]
for i in range(len(a)):
    x=1
    if a[i] not in visited:
        for j in range(i+1,len(a)):
            if(a[i]==a[j]):
                x+=1
        visited.append(a[i])
        print(a[i],"->",x)

\\Moving Zeroes to an end
a=[2,0,3,6,0,5,4,0,2,1,0]
j=0
for i in range(len(a)):
    if(a[i]!=0):
        a[i],a[j]=a[j],a[i]
        j+=1
print(a)

\\Check whether a given number is Armstrong Number
 n=153
s=0
temp=n
while(temp>0):
    x=temp%10
    s=x*x*x+s
    temp=temp//10
if(s==n):
    print("Armstrong")
else:
    print("Not an Armstrong")

\\Reverse of a Number
n=153
s=0
temp=n
while(temp>0):
        x=temp%10
        s=s*10+x (TTTTTTThisss is the only difference between Armstrong and Reverse of a number)
        temp=temp//10
print(s)

\\Palindrome number
class Solution(object):
    def isPalindrome(self, x):
        rev=0
        temp=x
        while(temp>0):
            s=temp%10
            rev=rev*10+s
            temp=temp//10
        if(rev==x):
            return True
        else:
            return False


\\Count the number of digits in a number 
class Solution:
    def countDigit(self, n):
        count=0
        while(n>0):
            last_digit=n%10
            count+=1
            n=n//10
        return count

\\Count the Digits That Divide a Number.
num=121
count=0
Original=num
while(num>0):
   last_digit=num%10
   if(Original%last_digit==0):
       count+=1
   num=num//10
print(count)

//Prime Number Code
is_prime=True
def pri(n):
    is_prime=True
    for i in range(2,n):
        if(n%i==0):
            is_prime=False
            break
    if is_prime:
        return n,"Is a prime number"
    else:
        return "It is not a Prime Number"
print(pri(5))

\\Frequency count of an element    Optimal Solution
a=[2,3,5,6,1,2,2,3,4,5,6]
freq={ }
for num in a:    \\Time Complexity O(n) and space complexity
    freq[num]=freq.get(num,0)+1
print(freq)
\\Space complexity is O(n) in case if all the elements are unique (single time appeared)

\\Rotate the array by k elements 
def reverse(arr,k):
    n=len(arr)
    k=k%n
    def rotate(i,j):
        while i<j:
            arr[i],arr[j]=arr[j],arr[i]
            i+=1
            j-=1
    rotate(0,len(arr)-1)
    rotate(0,k-1)
    rotate(k,n-1)
    
    return arr
print(reverse([1,2,3,4,5,6,7],1))

\\Reverse only letters in an String leetcode 
class Solution(object):
    def reverseOnlyLetters(self, s):
        s=list(s)
        i,j=0,len(s)-1
        while i<j:
            if s[i].isalpha() and  s[j].isalpha():   \\TC==O(n) as the pointers move inward so they visit each character at once
                s[i],s[j]=s[j],s[i]                  \\SC==O(n)
                i+=1
                j-=1
            elif not s[i].isalpha():
                i+=1
            else:
                j-=1
        return "".join(s)

\\Reverse Only vowels in a string
class Solution(object):
    def reverseVowels(self, s):
       i,j=0,len(s)-1
       s=list(s)
       vowels={"a","e","i","o","u","A","E","I","O","U"}
       while i<j:
        if s[i] in vowels and s[j] in vowels:
            s[i],s[j]=s[j],s[i]
            i+=1
            j-=1
        elif not s[i] in vowels:
            i+=1
        else:
            j-=1
       return "".join(s)
        












